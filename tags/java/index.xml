<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Java on pieterjd.be</title><link>https://www.pieterjd.be/tags/java/</link><description>Recent content in Java on pieterjd.be</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Wed, 28 Jun 2023 16:45:31 +0200</lastBuildDate><atom:link href="https://www.pieterjd.be/tags/java/index.xml" rel="self" type="application/rss+xml"/><item><title>Fallback Mechanism With Streams</title><link>https://www.pieterjd.be/posts/fallback-mechanism-with-streams/</link><pubDate>Wed, 28 Jun 2023 16:45:31 +0200</pubDate><guid>https://www.pieterjd.be/posts/fallback-mechanism-with-streams/</guid><description>The Problem I would like to summarize Person objects. Use the lastName if it is not null; if null, then use the firstName; else use the birthDay. If all these are null , then use the default text UNKNOWN.
Usually, you write something like this:
String summary = &amp;#34;&amp;#34;; if(p.getLastName() != null){ summary = p.getLastName(); } else if(p.getFirstName() != null){ summary = p.getFirstName(); } else if (p.getBirthDate() != null){ summary = p.</description></item><item><title>Advanced Grouping with Java streams</title><link>https://www.pieterjd.be/posts/java-stream-advanced-grouping/</link><pubDate>Mon, 22 May 2023 17:02:49 +0200</pubDate><guid>https://www.pieterjd.be/posts/java-stream-advanced-grouping/</guid><description>The problem I have a list of Person objects. I would like to group them per birth month, and only keep a List of lastnames.
I came up with this code from memory
Map&amp;lt;String, List&amp;lt;Person&amp;gt;&amp;gt; personsByMonth = persons.stream() .collect(Collectors.groupingBy(Person::getBirthMonth)); System.out.println(personsByMonth); And you get the following output (truncated for readability):
{JUNE=[Person{lastName='Doe 11', birthDate=2022-06-07}], JANUARY=[Person{lastName='Doe 10', birthDate=2023-01-26}]} But how do I get rid of the redundant information?
The solution The Collectors class provides quite a lot of variation of the groupingBy method.</description></item><item><title>Comparator and Null</title><link>https://www.pieterjd.be/posts/comparator-and-null/</link><pubDate>Wed, 03 May 2023 18:27:23 +0200</pubDate><guid>https://www.pieterjd.be/posts/comparator-and-null/</guid><description>Sorting collections has been quite easy with the &lt;code>Comparator&lt;/code> class. But how do you deal with possible &lt;code>null&lt;/code> values in for instance a &lt;code>List&lt;/code>? You probably see already the &lt;code>NullPointerException&lt;/code>s fly around, but fear not!</description></item><item><title>Stream examples Part 3 - Conclusion</title><link>https://www.pieterjd.be/posts/2019-04-08-streams-part3-conclusion/</link><pubDate>Mon, 08 Apr 2019 20:14:53 +0000</pubDate><guid>https://www.pieterjd.be/posts/2019-04-08-streams-part3-conclusion/</guid><description>I would like to wrap up with some snippets I use a lot!
Collect to a map When you want to collect to a Map, you need a function for the key and a function for the value.
Suppose you have a list of Person objects with a firstname and last name. If you want to map the firstname to the lastname, you would write something like this:
Map&amp;lt;String, String&amp;gt; firstToLastMap = persons.</description></item><item><title>Stream examples Part 2 - Reducers</title><link>https://www.pieterjd.be/posts/2019-04-01-streams-part2-reducers/</link><pubDate>Mon, 01 Apr 2019 17:30:53 +0000</pubDate><guid>https://www.pieterjd.be/posts/2019-04-01-streams-part2-reducers/</guid><description>Next to collectors, Streams offer reducers as well. You can consider it as building a result, starting from a partial solution and building on top of that. It is actually comparable to how the result is built up when using recursion.
As an example, let&amp;rsquo;s take the sum of all integers starting from 1 up until n. The trivial solution is 0 for the &amp;lsquo;empty case&amp;rsquo;, this is the value before you start looping.</description></item><item><title>Stream examples Part 1 - Collectors</title><link>https://www.pieterjd.be/posts/2019-03-31-streams-part1-collectors/</link><pubDate>Sun, 31 Mar 2019 12:34:19 +0000</pubDate><guid>https://www.pieterjd.be/posts/2019-03-31-streams-part1-collectors/</guid><description>Streams are quite fun - in short: it&amp;rsquo;s a different approach to writing loops. Suppose you have a List of Strings and you want to filter out the String starting with an &amp;rsquo;s' and put them in a new List.
List&amp;lt;String&amp;gt; sStrings = new ArrayList&amp;lt;&amp;gt;(); for(int i = 0; i &amp;lt; strings.size(); i++){ if(strings.get(i).startsWith(&amp;#39;s&amp;#39;)){ //do something with strings starting with s sStrings.add(strings.get(i)); } } Although still readable, there is a lot of redundant code: the for loop itself with the counter and condition, the if statement.</description></item></channel></rss>